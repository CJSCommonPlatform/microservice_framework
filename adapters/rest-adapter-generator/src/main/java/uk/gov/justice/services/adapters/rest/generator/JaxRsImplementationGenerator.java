package uk.gov.justice.services.adapters.rest.generator;

import static com.squareup.javapoet.MethodSpec.methodBuilder;
import static com.squareup.javapoet.TypeSpec.classBuilder;
import static javax.lang.model.element.Modifier.PUBLIC;
import static org.raml.model.ActionType.GET;
import static org.raml.model.ActionType.POST;
import static uk.gov.justice.services.adapters.rest.generator.Generators.byMimeTypeOrder;
import static uk.gov.justice.services.adapters.rest.generator.Names.DEFAULT_ANNOTATION_PARAMETER;
import static uk.gov.justice.services.adapters.rest.generator.Names.GENERIC_PAYLOAD_ARGUMENT_NAME;
import static uk.gov.justice.services.adapters.rest.generator.Names.RESOURCE_PACKAGE_NAME;
import static uk.gov.justice.services.adapters.rest.generator.Names.buildResourceMethodName;
import static uk.gov.justice.services.adapters.rest.generator.Names.buildResourceMethodNameWithNoMimeType;
import static uk.gov.justice.services.adapters.rest.generator.Names.resourceInterfaceNameOf;

import uk.gov.justice.raml.core.GeneratorConfig;
import uk.gov.justice.services.adapter.rest.RestProcessor;
import uk.gov.justice.services.core.annotation.Adapter;
import uk.gov.justice.services.core.annotation.Component;
import uk.gov.justice.services.core.dispatcher.AsynchronousDispatcher;
import uk.gov.justice.services.core.dispatcher.SynchronousDispatcher;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.json.JsonObject;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.Response;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import org.raml.model.Action;
import org.raml.model.ActionType;
import org.raml.model.Resource;
import org.raml.model.parameter.QueryParameter;
import org.raml.model.parameter.UriParameter;

/**
 * Internal code generation class for generating the JAX-RS implementation class that implements the
 * Interface generated by the {@link JaxRsInterfaceGenerator}.
 */
class JaxRsImplementationGenerator {

    private static final String PARAMS_PUT_STATEMENT_FORMAT = "params.put($S, $N)";
    private static final String SYNCHRONOUS_METHOD_STATEMENT = "return restProcessor.processSynchronously(syncDispatcher::dispatch, headers, params.build())";
    private static final String ASYNCHRONOUS_METHOD_STATEMENT = "return restProcessor.processAsynchronously(asyncDispatcher::dispatch, entity, headers, params.build())";

    private final GeneratorConfig configuration;

    /**
     * Constructor.
     *
     * @param configuration the generator configuration
     */
    JaxRsImplementationGenerator(final GeneratorConfig configuration) {
        this.configuration = configuration;
    }

    /**
     * Generate an implementation class for each resource.
     *
     * @param resources the collection of {@link Resource} to generate as implementation classes
     * @param component specifies the type of framework {@link Component} that is being implemented
     * @return a list of {@link TypeSpec} that represent the implementation classes
     */
    List<TypeSpec> generateFor(final Collection<Resource> resources, final Component component) {
        return resources.stream()
                .map(resource -> createClassFor(resource, component))
                .collect(Collectors.toList());
    }

    /**
     * Create an implementation class for the specified {@link Resource}
     *
     * @param resource  the resource to generate as an implementation class
     * @param component specifies the type of framework {@link Component} that is being implemented
     * @return a {@link TypeSpec} that represents the implementation class
     */
    private TypeSpec createClassFor(final Resource resource, final Component component) {
        final TypeSpec.Builder classSpecBuilder = classSpecFor(resource, component);

        resource.getActions().values().forEach(action -> {
            classSpecBuilder.addField(dispatcherFieldFor(action));
            classSpecBuilder.addMethods(forEach(action));
        });

        return classSpecBuilder.build();
    }

    /**
     * Creates a {@link TypeSpec.Builder} from an initial template of an implementation class
     *
     * @param resource  the resource to generate as an implementation class
     * @param component specifies the type of framework {@link Component} that is being implemented
     * @return a {@link TypeSpec.Builder} that represents the implementation class
     */
    private TypeSpec.Builder classSpecFor(final Resource resource, final Component component) {
        return classBuilder("Default" + resourceInterfaceNameOf(resource))
                .addSuperinterface(interfaceClassNameFor(resource))
                .addModifiers(PUBLIC)
                .addAnnotation(Stateless.class)
                .addAnnotation(AnnotationSpec.builder(Adapter.class)
                        .addMember(DEFAULT_ANNOTATION_PARAMETER, "$T.$L", Component.class, component)
                        .build())
                .addField(FieldSpec.builder(RestProcessor.class, "restProcessor")
                        .addAnnotation(Inject.class)
                        .build())
                .addField(FieldSpec.builder(HttpHeaders.class, "headers")
                        .addAnnotation(Context.class)
                        .build());
    }

    /**
     * Process the body or bodies for each action.
     *
     * @param action the action to process
     * @return the list of {@link MethodSpec} that represents each method for the action
     */
    private List<MethodSpec> forEach(final Action action) {
        if (!action.hasBody()) {
            return Collections.singletonList(processNoActionBody(action));
        } else {
            return processOneOrMoreActionBodies(action);
        }
    }

    /**
     * Process an action with no body.
     *
     * @param action the action to process
     * @return the {@link MethodSpec} that represents the method for the action
     */
    private MethodSpec processNoActionBody(final Action action) {
        final String resourceMethodName = buildResourceMethodNameWithNoMimeType(action);
        return generateResourceMethod(action, resourceMethodName).build();
    }

    /**
     * Process an action with one or more bodies.
     *
     * @param action the action to process
     * @return the list of {@link MethodSpec} that represents each method for the action
     */
    private List<MethodSpec> processOneOrMoreActionBodies(final Action action) {
        return action.getBody().values().stream()
                .sorted(byMimeTypeOrder())
                .map(bodyMimeType -> {
                    final String resourceMethodName = buildResourceMethodName(action, bodyMimeType);
                    final MethodSpec.Builder methodBuilder = generateResourceMethod(action, resourceMethodName);
                    return addToMethodWithMimeType(methodBuilder).build();
                }).collect(Collectors.toList());
    }

    /**
     * Generate the interface class name for implementation class
     *
     * @param resource generate for resource
     * @return the {@link ClassName} of the interface
     */
    private ClassName interfaceClassNameFor(final Resource resource) {
        return ClassName.get(configuration.getBasePackageName() + RESOURCE_PACKAGE_NAME, resourceInterfaceNameOf(resource));
    }

    /**
     * Uses the type of {@link Action} to provide a {@link SynchronousDispatcher} or an {@link
     * AsynchronousDispatcher} and provides the correct field definition as a {@link FieldSpec}.
     *
     * @param action the action to forEach
     * @return a {@link FieldSpec} representing the field definition.
     * @throws IllegalStateException if action type is not GET or POST
     */
    private FieldSpec dispatcherFieldFor(final Action action) {
        final ActionType actionType = action.getType();

        if (actionType == GET) {
            return synchronousDispatcherField();
        } else if (actionType == POST) {
            return asynchronousDispatcherField();
        } else {
            throw new IllegalStateException(String.format("Unsupported action type %s", actionType));
        }
    }

    /**
     * Generate the SynchronousDispatcher injected field.
     *
     * @return the {@link FieldSpec} that represents the generated field
     */
    private FieldSpec synchronousDispatcherField() {
        return FieldSpec.builder(SynchronousDispatcher.class, "syncDispatcher")
                .addAnnotation(Inject.class)
                .build();
    }

    /**
     * Generate the AsynchronousDispatcher injected field.
     *
     * @return the {@link FieldSpec} that represents the generated field
     */
    private FieldSpec asynchronousDispatcherField() {
        return FieldSpec.builder(AsynchronousDispatcher.class, "asyncDispatcher")
                .addAnnotation(Inject.class)
                .build();
    }

    /**
     * Add MimeType specific parameter to method.
     *
     * @param methodBuilder add parameter to this method builder
     * @return the method builder
     */
    private MethodSpec.Builder addToMethodWithMimeType(final MethodSpec.Builder methodBuilder) {
        return methodBuilder.addParameter(ParameterSpec
                .builder(JsonObject.class, GENERIC_PAYLOAD_ARGUMENT_NAME)
                .build());
    }

    /**
     * Generate a method for each {@link Action}.
     *
     * @param action             the action to generate as a method
     * @param resourceMethodName the resource method name to generate
     * @return a {@link MethodSpec} that represents the generated method
     */
    private MethodSpec.Builder generateResourceMethod(final Action action,
                                                      final String resourceMethodName) {
        final ActionType actionType = action.getType();
        final Map<String, QueryParameter> queryParams = action.getQueryParameters();
        final Map<String, UriParameter> pathParams = action.getResource().getUriParameters();
        final CodeBlock methodBody;

        if (actionType == GET) {
            methodBody = methodBody(pathParams, () -> methodBodyForGet(queryParams));
        } else if(actionType == POST) {
            methodBody = methodBody(pathParams, this::methodBodyForPost);
        }  else {
            throw new IllegalStateException(String.format("Unsupported action type %s", actionType));
        }

        return methodBuilder(resourceMethodName)
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameters(methodPathParams(pathParams))
                .addParameters(methodQueryParams(queryParams))
                .addCode(methodBody)
                .returns(Response.class);
    }

    /**
     * Produce code specific to the GET action type.
     *
     * @param queryParams the query parameters to add to a map
     * @return the {@link CodeBlock} representing the GET specific code
     */
    private CodeBlock methodBodyForGet(final Map<String, QueryParameter> queryParams) {
        return CodeBlock.builder()
                .add(putAllParamsInMap(queryParams.keySet()))
                .addStatement(SYNCHRONOUS_METHOD_STATEMENT)
                .build();
    }

    /**
     * Produce code specific to the POST action type.
     *
     * @return the {@link CodeBlock} representing the POST specific code
     */
    private CodeBlock methodBodyForPost() {
        return CodeBlock.builder()
                .addStatement(ASYNCHRONOUS_METHOD_STATEMENT)
                .build();
    }

    /**
     * General code that is for both GET and POST action type methods.
     *
     * @return the {@link CodeBlock} representing the general code
     */
    private CodeBlock methodBody(final Map<String, UriParameter> pathParams, final Supplier<CodeBlock> supplier) {
        final ClassName classStringType = ClassName.get(String.class);
        final ParameterizedTypeName classImmutableMapType = ParameterizedTypeName.get(
                ClassName.get(com.google.common.collect.ImmutableMap.Builder.class), classStringType, classStringType);

        return CodeBlock.builder()
                .addStatement("$T params = new $T()", classImmutableMapType, classImmutableMapType)
                .add(putAllParamsInMap(pathParams.keySet()))
                .add(supplier.get())
                .build();
    }

    /**
     * Generate code to add all parameters to the params map.
     *
     * @param paramNames the params to add to the map
     * @return the {@link CodeBlock} that represents the generated code
     */
    private CodeBlock putAllParamsInMap(final Collection<String> paramNames) {
        final CodeBlock.Builder builder = CodeBlock.builder();

        paramNames.stream().forEach(name ->
                builder.addStatement(PARAMS_PUT_STATEMENT_FORMAT, name, name)
        );

        return builder.build();
    }


    /**
     * Generate method parameters for all the path params.
     *
     * @param pathParams the path params to generate
     * @return list of {@link ParameterSpec} that represent the method parameters
     */
    private List<ParameterSpec> methodPathParams(final Map<String, UriParameter> pathParams) {
        return pathParams.keySet().stream().map(name ->
                ParameterSpec
                        .builder(String.class, name)
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Generate method parameters for all the query params.
     *
     * @param queryParams the query params to generate
     * @return list of {@link ParameterSpec} that represent the method parameters
     */
    private List<ParameterSpec> methodQueryParams(final Map<String, QueryParameter> queryParams) {
        return queryParams.keySet().stream().map(name ->
                ParameterSpec.builder(String.class, name)
                        .build()
        ).collect(Collectors.toList());
    }
}
